---
title: 逆向基础
date: 2022-07-18 17:10:13
permalink: /cs/reverse/base/
categories: 
  - 逆向工程
tags: 
  - 逆向
---

## 逆向工具
Postern： 全局代理工具。  
AndroidCrackTool：mac下Android逆向神器。[Android-Crack-Tool](https://github.com/Jermic/Android-Crack-Tool)  
Apktool:apk反编译工具[Apktool](https://github.com/iBotPeaches/Apktool)  
Jadx:Java反编译工具[jadx](https://github.com/skylot/jadx)  
Inspeckage:基于Xposed的动态分析工具[Inspeckage](https://github.com/ac-pm/Inspeckage)  
Frida:hook工具[frida](https://github.com/frida/frida)  
Objection:Frida的集成化工具[objection](https://github.com/sensepost/objection)  
FridadexDump:Frida集成工具，实现一键脱壳[frida-dexdump](https://github.com/hluwa/frida-dexdump)  
Fart:内存中DexFile结构体完整dex的dump进行脱壳[FART](https://github.com/hanbinglengyue/FART)  
DeveloperHelper:基于Xposed写的辅助工具，常用于查看Activity名、查看加固类型、查看Activity结构、自动脱壳。  
UCrack:基于Xposed写的辅助工具，集成了自动网络抓包、网络堆栈爆破、文件日志、WebView调试环境、自动脱壳、Native函数注册监控、记录程序自杀堆栈等功能。  
IDA Pro:so层调试工具。  
DDMS：是Android开发环境中的Dalvik虚拟机调试监控服务，它提供查看线程和堆信息、logcat、进程、广播状态信息等功能。
## 编码
### base64
Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。  
1个Base64字符对应的是6bit，1个字节对应的是8bit，将每3个字节变为24bit，再将24bit分为4组每组前补00，扩展成32个bit，即四个字节，每个字节对应的将是一个小于64的数字，在转为字符就是base64编码。  
对于不足3个字节的地方，实际都会在后面补0，直到有24个二进制位为止。编码为"="  
**python实现base64:**
```python
import base64

text = ''
# encode
encode_data = base64.b64encode(text.encode())
# decode
decode_data = base64.b64decode(encode_data)
```
**javascript实现base64:**
```javascript
// 使用base64.js
<script src="base64.js"></script>
const Base64 = require('js-base64').Base64;
Base64.encode('我是一段需要处理的字符');
Base64.decode('5oiR5piv5LiA5q616ZyA6KaB5aSE55CG55qE5a2X56ym');

// 浏览器
window.btoa(unescape(encodeURIComponent('我是一段需要处理的字符')))
decodeURIComponent(escape(window.atob('5oiR5piv5LiA5q616ZyA6KaB5aSE55CG55qE5a2X56ym')))

// nodejs
// 普通字符串
new Buffer(String).toString('base64');
new Buffer(base64Str, 'base64').toString();
// 十六进制Hex
new Buffer(String, 'base64').toString('hex');
new Buffer(base64Str, 'hex').toString('utf8');
```
原生js:
```javascript
var t, n = "3.7.0", r = "function" == typeof atob, e = "function" == typeof btoa, o = "function" == typeof Buffer,
    u = "function" == typeof TextDecoder ? new TextDecoder : void 0,
    i = "function" == typeof TextEncoder ? new TextEncoder : void 0,
    f = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="), c = (t = {},
        f.forEach((function (n, r) {
                return t[n] = r
            }
        )),
        t), a = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,
    d = String.fromCharCode.bind(String),
    s = "function" == typeof Uint8Array.from ? Uint8Array.from.bind(Uint8Array) : function (t, n) {
        return void 0 === n && (n = function (t) {
                return t
            }
        ),
            new Uint8Array(Array.prototype.slice.call(t, 0).map(n))
    }
    , l = function (t) {
        return t.replace(/[+\/]/g, (function (t) {
                return "+" == t ? "-" : "_"
            }
        )).replace(/=+$/m, "")
    }, h = function (t) {
        return t.replace(/[^A-Za-z0-9\+\/]/g, "")
    }, p = function (t) {
        for (var n, r, e, o, u = "", i = t.length % 3, c = 0; c < t.length;) {
            if ((r = t.charCodeAt(c++)) > 255 || (e = t.charCodeAt(c++)) > 255 || (o = t.charCodeAt(c++)) > 255)
                throw new TypeError("invalid character found");
            u += f[(n = r << 16 | e << 8 | o) >> 18 & 63] + f[n >> 12 & 63] + f[n >> 6 & 63] + f[63 & n]
        }
        return i ? u.slice(0, i - 3) + "===".substring(i) : u
    }, y = e ? function (t) {
            return btoa(t)
        }
        : o ? function (t) {
                return Buffer.from(t, "binary").toString("base64")
            }
            : p, A = o ? function (t) {
            return Buffer.from(t).toString("base64")
        }
        : function (t) {
            for (var n = [], r = 0, e = t.length; r < e; r += 4096)
                n.push(d.apply(null, t.subarray(r, r + 4096)));
            return y(n.join(""))
        }
    , b = function (t, n) {
        return void 0 === n && (n = !1),
            n ? l(A(t)) : A(t)
    }, g = function (t) {
        if (t.length < 2)
            return (n = t.charCodeAt(0)) < 128 ? t : n < 2048 ? d(192 | n >>> 6) + d(128 | 63 & n) : d(224 | n >>> 12 & 15) + d(128 | n >>> 6 & 63) + d(128 | 63 & n);
        var n = 65536 + 1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320);
        return d(240 | n >>> 18 & 7) + d(128 | n >>> 12 & 63) + d(128 | n >>> 6 & 63) + d(128 | 63 & n)
    }, B = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, x = function (t) {
        return t.replace(B, g)
    }, C = o ? function (t) {
            return Buffer.from(t, "utf8").toString("base64")
        }
        : i ? function (t) {
                return A(i.encode(t))
            }
            : function (t) {
                return y(x(t))
            }
    , m = function (t, n) {
        return void 0 === n && (n = !1),
            n ? l(C(t)) : C(t)
    }, v = function (t) {
        return m(t, !0)
    }, U = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, F = function (t) {
        switch (t.length) {
            case 4:
                var n = ((7 & t.charCodeAt(0)) << 18 | (63 & t.charCodeAt(1)) << 12 | (63 & t.charCodeAt(2)) << 6 | 63 & t.charCodeAt(3)) - 65536;
                return d(55296 + (n >>> 10)) + d(56320 + (1023 & n));
            case 3:
                return d((15 & t.charCodeAt(0)) << 12 | (63 & t.charCodeAt(1)) << 6 | 63 & t.charCodeAt(2));
            default:
                return d((31 & t.charCodeAt(0)) << 6 | 63 & t.charCodeAt(1))
        }
    }, w = function (t) {
        return t.replace(U, F)
    }, S = function (t) {
        if (t = t.replace(/\s+/g, ""),
            !a.test(t))
            throw new TypeError("malformed base64.");
        t += "==".slice(2 - (3 & t.length));
        for (var n, r, e, o = "", u = 0; u < t.length;)
            n = c[t.charAt(u++)] << 18 | c[t.charAt(u++)] << 12 | (r = c[t.charAt(u++)]) << 6 | (e = c[t.charAt(u++)]),
                o += 64 === r ? d(n >> 16 & 255) : 64 === e ? d(n >> 16 & 255, n >> 8 & 255) : d(n >> 16 & 255, n >> 8 & 255, 255 & n);
        return o
    }, E = r ? function (t) {
            return atob(h(t))
        }
        : o ? function (t) {
                return Buffer.from(t, "base64").toString("binary")
            }
            : S, D = o ? function (t) {
            return s(Buffer.from(t, "base64"))
        }
        : function (t) {
            return s(E(t), (function (t) {
                    return t.charCodeAt(0)
                }
            ))
        }
    , R = function (t) {
        return D(T(t))
    }, z = o ? function (t) {
            return Buffer.from(t, "base64").toString("utf8")
        }
        : u ? function (t) {
                return u.decode(D(t))
            }
            : function (t) {
                return w(E(t))
            }
    , T = function (t) {
        return h(t.replace(/[-_]/g, (function (t) {
                return "-" == t ? "+" : "/"
            }
        )))
    }, Z = function (t) {
        return z(T(t))
    }, j = function (t) {
        return {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }, I = function () {
        var t = function (t, n) {
            return Object.defineProperty(String.prototype, t, j(n))
        };
        t("fromBase64", (function () {
                return Z(this)
            }
        )),
            t("toBase64", (function (t) {
                    return m(this, t)
                }
            )),
            t("toBase64URI", (function () {
                    return m(this, !0)
                }
            )),
            t("toBase64URL", (function () {
                    return m(this, !0)
                }
            )),
            t("toUint8Array", (function () {
                    return R(this)
                }
            ))
    }, O = function () {
        var t = function (t, n) {
            return Object.defineProperty(Uint8Array.prototype, t, j(n))
        };
        t("toBase64", (function (t) {
                return b(this, t)
            }
        )),
            t("toBase64URI", (function () {
                    return b(this, !0)
                }
            )),
            t("toBase64URL", (function () {
                    return b(this, !0)
                }
            ))
    }, P = {
        version: n,
        VERSION: "3.7.0",
        atob: E,
        atobPolyfill: S,
        btoa: y,
        btoaPolyfill: p,
        fromBase64: Z,
        toBase64: m,
        encode: m,
        encodeURI: v,
        encodeURL: v,
        utob: x,
        btou: w,
        decode: Z,
        isValid: function (t) {
            if ("string" != typeof t)
                return !1;
            var n = t.replace(/\s+/g, "").replace(/=+$/, "");
            return !/[^\s0-9a-zA-Z\+/]/.test(n) || !/[^\s0-9a-zA-Z\-_]/.test(n)
        },
        fromUint8Array: b,
        toUint8Array: R,
        extendString: I,
        extendUint8Array: O,
        extendBuiltins: function () {
            I(),
                O()
        },
        Base64: {}
    };

console.log(P.toBase64("我是一段需要处理的字符"))
```
**java实现base64**
```java
// java8
final Base64.Decoder decoder = Base64.getDecoder();
final Base64.Encoder encoder = Base64.getEncoder();
final String text = "字串文字";
final byte[] textByte = text.getBytes("UTF-8");
// 编码
final String encodedText = encoder.encodeToString(textByte);
System.out.println(encodedText);
// 解码
System.out.println(new String(decoder.decode(encodedText), "UTF-8"));
```
## adb使用
### 基本使用
```shell
#进入shell
adb shell

#连接设备
adb connect ip

#查看连接的设备
adb devices -l  
-l:显示设备信息

#选择设备
adb -s 设备名

#文件传输
#设备到本地：  
adb pull remote local   

#本地到设备：  
adb push local remote

#停止adb服务
adb kill-server

#设置端口转发
adb forward tcp:27043 tcp:27043  
adb forward tcp:27042 tcp:27042

# 清日志
adb logcat -c
```
### Activity 管理器(am)
https://developer.android.com/studio/command-line/adb?hl=zh-cn#am  
```shell
#获取APP包名
adb shell am monitor  
#查看当前应用
adb shell dumpsys window | findstr mCurrentFocus   
```
### 软件包管理器(pm)
https://developer.android.com/studio/command-line/adb?hl=zh-cn#pm
```shell
#查看设备安装包名 
adb shell pm list packages
#查看安装包的路径
adb shell pm path packagename
#安装/卸载Android 应用
adb shell pm install/uninstall packagesname 
#aapt解析包信息
aapt dump badging /Users/macbook/Desktop/app.apk  
aapt d badging packagename
```
### 截图
```shell
screencap filename  
adb shell screencap /sdcard/screen.png
```
### 录制视频
```shell
screenrecord [options] filename  
adb shell screenrecord /sdcard/demo.mp4  
options:  
size widthxheight : 设置视频大小  
--bit-rate rate : 设置视频的比特率  
--time-limit time : 最大录制时长  
--rotate : 将输出旋转 90 度  
--verbose : 在命令行屏幕显示日志信息 
```