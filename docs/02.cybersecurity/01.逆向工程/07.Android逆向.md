---
title: Android逆向
date: 2022-09-22 13:49:13
permalink: /cs/reverse/androidreverse/
tags: 
  - 逆向
  - Android
categories: 
  - 逆向工程
---

## 反编译
### apktools
反编译：`apktppl d -r test.apk`  
回编译：`apktppl b test`

## smali
### 关键字
|名称|注释|
|---|---|
|.class|类名|
|.super|父类名，继承的上级类名名称|
|.source|源名|
|.field|变量|
|.method|方法名|
|.register|寄存器|
|.end method|方法名的结束|
|public|公有|
|protected|半公开，只有同一家人才能用|
|private|私有，只能自己使用|
|.parameter|方法参数|
|.prologue|方法开始|
|.line xxx|位于第xxx行|
### 数据类型对应
|smali类型|java类型|注释|
|---|---|---|
|V|void|无返回值|
|Z|boolean|布尔值类型，返回0或1|
|B|byte|字节类型，返回字节|
|S|short|短整数类型，返回数字|
|C|char|字符类型，返回字符|
|I|int|整数类型，返回数字|
|J|long （64位 需要2个寄存器存储）|长整数类型，返回数字|
|F|float|单浮点类型，返回数字|
|D|double （64位 需要2个寄存器存储）|双浮点类型，返回数字|
|string|String|文本类型，返回字符串|
|Lxxx/xxx/xxx|object|对象类型，返回对象|
### 常用指令
|关键字|注释|
|---|---|
|const|重写整数属性，真假属性内容，只能是数字类型|
|const-string|重写字符串内容|
|const-wide|重写长整数类型，多用于修改到期时间。|
|return|返回指令|
|if-eq|全称equal(a=b)，比较寄存器ab内容，相同则跳|
|if-ne|全称not equal(a!=b)，ab内容不相同则跳|
|if-eqz|全称equal zero(a=0)，z即是0的标记，a等于0则跳|
|if-nez|全称not equal zero(a!=0)，a不等于0则跳|
|if-ge|全称greater equal(a>=b)，a大于或等于则跳|
|if-le|全称little equal(a<=b)，a小于或等于则跳|
|goto|强制跳到指定位置|
|switch|分支跳转，一般会有多个分支线，并根据指令跳转到适当位置|
|iget|获取寄存器数据|

## 去除广告
开屏广告：使用mt管理器的**activity记录**定位activity，修改或hook广告activity。  
弹窗：hook弹窗的show()方法。  
修改xml隐藏布局：
```xml
android:visibility="gone"
```

## 签名校验 
**常见的校验特征**：  
- kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因。  
- system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。  
- finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理。

**一键签名工具**：  
MT、NP、ARMPro、CNFIX、Modex
### 普通签名校验
```java
private boolean SignCheck() {
    String trueSignMD5 = "d0add9987c7c84aeb7198c3ff26ca152";
    String nowSignMD5 = "";
    try {
        // 得到签名的MD5
        PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES);
        Signature[] signs = packageInfo.signatures;
        String signBase64 = Base64Util.encodeToString(signs[0].toByteArray());
        nowSignMD5 = MD5Utils.MD5(signBase64);
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    return trueSignMD5.equals(nowSignMD5);
}
```
### IO重定向

## app检测
### root检测
```java
fun isDeviceRooted(): Boolean {
    return checkRootMethod1() || checkRootMethod2() || checkRootMethod3()
}

fun checkRootMethod1(): Boolean {
    val buildTags = android.os.Build.TAGS
    return buildTags != null && buildTags.contains("test-keys")
}

fun checkRootMethod2(): Boolean {
    val paths = arrayOf("/system/app/Superuser.apk", "/sbin/su", "/system/bin/su", "/system/xbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su",
            "/system/bin/failsafe/su", "/data/local/su", "/su/bin/su")
    for (path in paths) {
        if (File(path).exists()) return true
    }
    return false
}

fun checkRootMethod3(): Boolean {
    var process: Process? = null
    return try {
        process = Runtime.getRuntime().exec(arrayOf("/system/xbin/which", "su"))
        val bufferedReader = BufferedReader(InputStreamReader(process.inputStream))
        bufferedReader.readLine() != null
    } catch (t: Throwable) {
        false
    } finally {
        process?.destroy()
    }
}
```
### 模拟器检测
```java
fun isEmulator(): Boolean { 
        return Build.FINGERPRINT.startsWith("generic") || Build.FINGERPRINT.startsWith("unknown") || Build.MODEL.contains("google_sdk") Build.MODEL.contains("Emulator") || Build.MODEL.contains("Android SDK built for x86") || Build.MANUFACTURER.contains("Genymotion") || Build.HOST.startsWith("Build") || Build.PRODUCT == "google_sdk" 
        }
```
### 反调试检测
安卓系统自带调试检测函数
```java
fun checkForDebugger() {  
    if (Debug.isDebuggerConnected()) {  
        // 如果调试器已连接，则终止应用程序  
        System.exit(0)  
    }  
}
```
debuggable属性
```java
public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this
{
    boolean isDebug = context.getApplicationInfo() != null &&
            (context.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    return isDebug;
}

```
ptrace检测
```java
int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote
{
    return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试
}
```
每个进程同时刻只能被1个调试进程ptrace  ，主动ptrace本进程可以使得其他调试器无法调试

调试进程名检测
```java
int SearchObjProcess()
{
    FILE* pfile=NULL;
    char buf[0x1000]={0};

    pfile=popen("ps","r");
    if(NULL==pfile)
    {
        //LOGA("SearchObjProcess popen打开命令失败!\n");
        return -1;
    }
    // 获取结果
    //LOGA("popen方案:\n");
    while(fgets(buf,sizeof(buf),pfile))
    {

        char* strA=NULL;
        char* strB=NULL;
        char* strC=NULL;
        char* strD=NULL;
        strA=strstr(buf,"android_server");//通过查找匹配子串判断
        strB=strstr(buf,"gdbserver");
        strC=strstr(buf,"gdb");
        strD=strstr(buf,"fuwu");
        if(strA || strB ||strC || strD)
        {
            return 1;
            // 执行到这里，判定为调试状态

        }
    }
    pclose(pfile);
    return 0;
}
```

## 动态调试
### 修改debug权限
在AndroidManifest.xml里添加可调试权限：`android:debuggable="true"`



### ida动态调试
端口转发
```
adb forward tcp:23946 tcp:23946
```


## so文件调用
### frida-rpc
### andserver
### unidbg