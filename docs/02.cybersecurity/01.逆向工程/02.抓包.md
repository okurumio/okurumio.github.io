---
title: 抓包对抗
date: 2022-07-18 17:10:13
permalink: /cs/reverse/packetcapture/
categories: 
  - 逆向工程
tags: 
  - 逆向
---

## 抓包工具
**Postern**: 全局代理工具。  
**ProxyDriod**: 强制全局代理工具。  
**Charles**: http抓包。  
**Fiddler**  : http抓包。  
**WireShark**：会话层抓包。  
**TcpDump**：会话层抓包。  
**Jnettop**：实时查看流量走势和对方IP地址，直观生动。  
**PacketCapture**： VPN抓包工具，原理是在本地创建一个VPN，使所有请求都从VPN中流过。  
**HTTPCanary**：移动端VPN抓包工具。  
**BrupSuite**：一个较为专业的抓包工具。  
**Hping**：面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具，具有跟踪路由模式。  
**Proxifier**：一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。  
[r0capture](https://github.com/r0ysue/r0capture): 安卓应用层抓包通杀脚本。  
[ecapture](https://ecapture.cc/zh/): 无CA证书HTTPS/TLS数据抓包eBPF技术驱动。
## 禁用代理
```java
OkHttpClient okHttpClient = new OkHttpClient.Builder(). proxy(Proxy.NO_PROXY). build();
```
hook替换no proxy防抓包检测函数
```javascript
function replaceKill(){  
	// 替换掉崩掉时的内容，打印崩掉时的参数和pid，不执行崩掉的逻辑，让程序不要崩  
    console.log("Preventing from killing ...")  
    var kill_addr = Module.findExportByName("libc.so", "kill");  
    // var kill = new NativeFunction(kill_addr,"int",['int','int']);  
    Interceptor.replace(kill_addr,new NativeCallback(function(arg0,arg1){  
        console.log("arg0=> ",arg0)  
        console.log("arg1=> ",arg1)  
  
    },"int",['int','int']))  
}  
  
function main(){  
    replaceKill()  
}  
```
通过判断`java.net.NetworkInterface.getName()`是否等于`tun0`或`ppp0` 或者 `android.net.ConnectivityManager.getNetworkCapabilities`来判断是否存在VPN抓包。  
**hook检测函数：**
```javascript
Java.perform(function () {
	var String = Java.use("java.lang.String");
	var NetworkInterface = Java.use("java.net.NetworkInterface");
	NetworkInterface.getName.implementation = function() {
		var name = this.getName();
		console.log("name: " + name);
		if (name == "tun0") {
			var result = String.$new("rmnet_data0");
			console.log("hook result:" + result);
			return result;
		} else {
			return name;
		}
	};
	var ConnectivityManager = Java.use("android.net.ConnectivityManager");
	ConnectivityManager.getNetworkCapabilities.implementation = function (args) {
		var result = this.getNetworkCapabilities(args);
		console.log("vpn result: " + result);
		return null
	};
})
```
## SSL Pinning
一种防止中间人攻击（MITM）的技术，对证书进行校验，如果收到的证书不被客户端信任，就直接断开连接不继续请求。  
1、服务端使用了某个权威证书颁发机构（CA）颁发的证书，并且在APP中校验证书是否正常.  
2、服务端使用了CA颁发的证书或者自己给自己颁发证书，并且在APP中校验证书本身是否正常的，需要将证书与APP本体一同下发。有把证书混淆在代码里面藏起来的，也有直接放在资源目录下的。  

### 绕过证书检查
**justtrustme**：  
通过xposed将APK中所有用于校验SSL证书的API都进行了Hook，从而绕过证书检查.  
**justtrustme++**:  
针对于使用了Okhttp且被混淆的app。hook那些日常开发中很少用到的类，但okhttp在验证证书之前又必须用到的类，然后通过这个类的调用堆栈，去识别okhttp的相关类。  
[by军哥](https://github.com/JunGe-Y/JustTrustMePP)  
**objection**:  
`android ansslpinning disable`
### 证书hook
**获取证书密码**:  
hook框架层代码`java.security.KeyStore`,使密码自吐。
```javascript
function hook_KeyStore_load(){
	Java.perform(function(){
		var StringClass = Java.use("java.lang.String");
		var KeyStore = Jave.use("java.security.KeyStore");
		KeyStore.load.overload('java.security.KeyStore$LoadStoreParameter').implementation = function (arg0){
			console.log("KeyStore.load", arg0);
			this.load(arg0);
		};
		KeyStore.load.overload("java.io.InputStream", '[C').implementation = function (arg0, arg1){
			printStack("KeyStore.load");
			console.log("KeyStore.load", arg0, arg1 ? StringClass.$new(arg1):null);
			this.load(arg0, arg1)
		};
	})
}
```
**获取证书文件**:  
通常为后缀名为p12、pfx的文件。
