---
title: frida
date: 2022-08-18 17:10:13
permalink: /cs/reverse/frida/
categories: 
  - 逆向工程
tags: 
  - 逆向
  - frida
---
## FRIDA
一款轻量级HOOK框架-[官网](https://github.com/frida)  
**动态二进制插桩技术（DBI）:** 将额外代码注入到二进制可执行文件中，通过修改汇编地址，改变程序运行内容，运行后再返回到原来程序运行出处，从而实现程序的额外功能。  
[Frida源码分析](https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/)
## 安装
**frida：**
```shell
# python3.7以上
pip install frida
pip install frida-tools
```
**frida-server：**
[frida-server下载](https://github.com/frida/frida/releases)  
查看cpu信息：`cat /proc/cpuinfo`  
**启动frida-server**
```shell
adb shell
su
cd /data/local/tmp
chmod 777 frida-server
./frida-server
```
**端口转发**
```shell
adb forward tcp:27042 tcp:27042
adb forward tcp:27043 tcp:27043
```
## firda命令
```shell
# 列举设备正在运行的进程（进程ID，进程名，包名）
frida-ps -Ua

# 打印设备上所有的进程（进程ID，进程名，包名）
frida-ps -Uai

# frida加载js脚本
frida -U -l **.js  -f  进程名或进程ID或包名  --no-pause

# frida杀死进程
frida-kill -U 进程名或进程ID或包名

# 跟踪某个函数
frida-trace -U -f Name -i "函数名"

# 跟踪某个方法
frida-trace -U -f Name -m "方法名"
```
## Hook
```python
import frida
import sys

# 从此处开始定义用来Hook的javascript代码
jscode = """  
    Java.perform(function(){  
        var MainActivity = Java.use('com.example.testfrida.MainActivity'); //获得MainActivity类
        MainActivity.testFrida.implementation = function(){
            send('Statr! Hook!'); //发送信息，用于回调python中的函数
            return 'Change String!' //劫持返回值，修改为我们想要返回的字符串
        }
    });
"""

def on_message(message,data): #js中执行send函数后要回调的函数
    print(message)

process = frida.get_remote_device().attach('com.example.testfrida') #得到设备并劫持进程com.example.testfrida
script = process.create_script(jscode) #创建js脚本
script.on('message',on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数
script.load() #加载脚本
sys.stdin.read()
```
**从app启动开始hook：**
```python
device = frida.get_usb_device()
# 获取劫持app的pid
pid = device.spawn(['com.example.testfrida'])  
  
process = device.attach(pid)  
script = process.create_script(jscode)  # 创建js脚本  
script.on('message', on_message)  # 加载回调函数
script.load()  # 加载脚本  
# 重启app
device.resume(pid) 
sys.stdin.read()
```
### HOOK方法
**hook object对象**
```python
Java.perform(function(){  
    let a = Java.use("com.sina.sinahttpsignlibrary.a");  
    a["a"].overload('[Ljava.lang.Object;').implementation = function (objArr) {  
        console.log('a is called' + ', ' + 'objArr: ' + objArr);  
        let ret = this.a(objArr);  
        console.log('a ret value is ' + ret);  
        return ret;  
    };  
});
```
**hook普通方法**
```javascript
Java.perform(function () {
   var utils = Java.use('com.app.test');//Java.use('类名')
    // func为方法名
    utils.func.implementation = function (a) {
        console.log("Hook Start...");
        send(arguments[0]);  //打印方法第一个参数 用send(a)也行
    } }); 
```
**hook构造方法**
```javascript
Java.perform(function () { 	
	var utils = Java.use('com.app.test');
    utils.$init.implementation = function (a) {
        console.log("Hook Start..."); 	
        send(arguments[0]);
        return this.$init(1000);
    } }); 
```
**hook重载方法**
```javascript
Java.perform(function () {
    var utils = Java.use('com.app.test');
    utils.test.overload("int").implementation = function (a) {
        console.log("Hook Start...");
        send(arguments[0]);
        return "helloworld";
    } }); 
```
**hook构造对象参数**
```javascript
Java.perform(function () { 	
    var utils = Java.use('com.app.test'); 	
    var money = Java.use('com.qiang.fridaapp.Money');
    utils.test.overload().implementation = function () {
        // send("Hook Start...");
        // 拦截utils方法然后构造一个money方法返回
        var mon = money.$new(2000); 		
        // send(mon.getInfo()); 		
        return this.test(800);
    } }); 
```
**hook修改对象属性**
```javascript
Java.perform(function () {
    var utils = Java.use('com.qiang.fridaapp.Utils');
    var money = Java.use('com.qiang.fridaapp.Money');
    var clazz = Java.use('java.lang.Class');
    utils.test.overload().implementation = function () {
        send("Hook Start...");
       
        var mon = money.$new(200,"RMB");
        send(mon.getInfo());
        
        // 修改一个对象的内部值，利用反射进行操作，用cast获取对应类的class类型，
        var num= Java.cast(mon.getClass(),clazz).getDeclaredField('num');
        // 值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查;实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问,由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的 
        num.setAccessible(true);
       
        num.setInt(mon, 2000);
        send(mon.getInfo());
       
        return this.test();
    } }); 
```
### hook匿名内部类
```javascript
 Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
    } }); 
```
### hook打印堆栈信息
```javascript
Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
        printStack();
    }
    function printStack(){
        var threadef = Java.use('java.lang.Thread');
        var threadinstance = threadef.$new();
        var stack = threadinstance.currentThread().getStackTrace();
        for(var i = 0;i<stack.length;i++){
            send("stack:" + stack[i].toString());
        }
    } }); 
```
### fridarpc
```javascript
rpc.exports = { add: function (a, b) { return a + b; },
```
### 字节数组,字符串互转
```javascript
Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
        var bytes=stringToBytes("hello world!")
        send(bytes); 
        var str=byteToString(bytes)
        send(str);
    }
    
    function stringToBytes(str) {  
        var ch, st, re = []; 
        for(var i = 0; i < str.length; i++ ) { 
            ch = str.charCodeAt(i);  
            st = [];                 
            do{
                st.push( ch & 0xFF );
                ch = ch >> 8;
            }
            while(ch);
            re = re.concat(st.reverse());
        }
        return re;  
    } 
    
    function byteToString(arr){  
        if(typeof arr === 'string'){  
            return arr;  
        }  
        var str='',  
        _arr = arr;  
        for(var i=0; i<_arr.length; i++) {  
            var one =_arr[i].toString(2), v=one.match(/^1+?(?=0)/);  
            if(v && one.length == 8){  
                var bytesLength = v[0].length;  
                var store = _arr[i].toString(2).slice(7 - bytesLength);  
                for(var st=1; st < bytesLength; st++) {  
                    store+=_arr[st + i].toString(2).slice(2);  
                }  
                str+=String.fromCharCode(parseInt(store, 2));  
                i+=bytesLength-1;  
            } else {  
                str+=String.fromCharCode(_arr[i]);  
            }  
        }  
        return str;  
    } });
```
### hook插件化apk
[使用frida hook插件化apk](https://bbs.kanxue.com/thread-258772.html)  
由于是插件化apk，类加载是在插件化框架自定义的，所以classloader不能使用默认的。
```javascript
Java.perform(function () {
    // 使用Java.enumerateClassLoaders(callbacks)来打印出所有的加载器
    Java.enumerateClassLoaders({
        "onMatch": function(loader) {
            try {
                if (loader.findClass('com.mango.hnxwlb.utils.Md5Util')) {
                    console.log(loader);
                    // 修改loader
                    Java.classFactory.loader = loader;
                }   
            } catch (error){
                console.log('not find');
            }
        },
        "onComplete": function() {
            console.log("success");
        },
    });
    // 使用Java.classFactory.use进行hook
    var videoController = Java.classFactory.use("com.mango.hnxwlb.utils.Md5Util");
    videoController.getToken.implementation = function(p0) {
        var gettoken = this.getToken();
        console.log(p0)
        console.log(gettoken)
        return gettoken;
    };
});
```
参考文章：[使用frida hook插件化apk](https://bbs.kanxue.com/thread-258772.htm#frida%E6%9E%9A%E4%B8%BEclassloader)
### native层hook
```javascript
Java.perform(function(){  
    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名  
    Interceptor.attach(Module.findExportByName("libfridaso.so","Java_com_example_fridaso_FridaSoDefine_FridaSo"),{  
        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数  
        onEnter: function(args) {  
            send("Hook start");  
            console.log("1----", Memory.readCString(args[0]))  
			console.log("2----", Memory.readCString(args[1]))  
			console.log("3----", Memory.readCString(args[2]))  
			console.log("4----", Memory.readCString(args[3]))
            send("args[2]=" + args[2]); //打印我们java层第一个传入的参数  
            send("args[3]=" + args[3]); //打印我们java层传入的第二个参数  
        },  
        onLeave: function(retval){ //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值  
            send("return:"+retval); //打印返回值  
            retval.replace(0); //替换返回值为0  
            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数  
			var jstrings = env.newStringUtf("tamper"); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针  
			retval.replace(jstrings); //替换返回值
        }  
    });  
});
```
```javascript
var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数  
var jstrings = env.newStringUtf("tamper"); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针  
//send("return1:"+jstrings);  
console.log("end1----", Memory.readCString(jstrings))  
retval.replace(jstrings); //替换返回值
```
## 反调试
- **检测frida-server文件名 ,检测27042默认端口：**   
修改frida-server文件名，修改转发端口。  
- **检测D-Bus：** 
- **检测/proc/pid/maps映射文件：**   
当挂上frida后对应的maps文件中会出现re.frida.server之类的特征，这是在使用frida server的时候自动创建的，其中存放着frida的功能模块,hook跳过检测：
```javascript
function main() {
  const openPtr = Module.getExportByName('libc.so', 'open');
  const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);
  var readPtr = Module.findExportByName("libc.so", "read");
  var read = new NativeFunction(readPtr, 'int', ['int', 'pointer', "int"]);
  var fakePath = "/data/data/com.app/maps";
  var file = new File(fakePath, "w");
  var buffer = Memory.alloc(512);
  Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) {
      var pathname = Memory.readUtf8String(pathnameptr);
      var realFd = open(pathnameptr, flag);
      if (pathname.indexOf("maps") >= 0) {
          while (parseInt(read(realFd, buffer, 512)) !== 0) {
              var oneLine = Memory.readCString(buffer);
              if (oneLine.indexOf("tmp") === -1) {
                  file.write(oneLine);
              }
          }
          var filename = Memory.allocUtf8String(fakePath);
          return open(filename, flag);
      }
      var fd = open(pathnameptr, flag);
      return fd;
  }, 'int', ['pointer', 'int']));
}
setImmediate(main)
```

- **检测/proc/pid/tast/tid/stat或/proc/pid/tast/tid/status** 
- **双进程保护：**
用spawn模式启动app `frida -U -f com.asiainfo.app --no-pause` 之后进行hook `frida -U com.asiainfo.app -l test.js`