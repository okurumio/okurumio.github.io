---
title: frida
date: 2022-08-18 17:10:13
permalink: /cs/reverse/frida/
categories: 
  - 逆向工程
tags: 
  - 逆向
  - frida
---
## FRIDA
一款轻量级HOOK框架-[官网](https://github.com/frida)
使用的是动态二进制插桩技术（DBI）
## 安装
**frida：**
```shell
# python3.7以上
pip install frida
pip install frida-tools
```
**frida-server：**
[frida-server下载](https://github.com/frida/frida/releases)  
查看cpu信息：`cat /proc/cpuinfo`  
**启动frida-server**
```shell
adb shell
su
cd /data/local/tmp
chmod 777 frida-server
./frida-server
```
**端口转发**
```shell
adb forward tcp:27042 tcp:27042
adb forward tcp:27043 tcp:27043
```
## firda命令
```shell
# 列举设备正在运行的进程（进程ID，进程名，包名）
frida-ps -Ua

#打印设备上所有的进程（进程ID，进程名，包名）
frida-ps -Uai

#frida加载js脚本
frida -U -l **.js  -f  进程名或进程ID或包名  --no-pause

#frida杀死进程
frida-kill -U 进程名或进程ID或包名

# 跟踪某个函数
frida-trace -U -f Name -i "函数名"

# 跟踪某个方法
frida-trace -U -f Name -m "方法名"
```
## Hook
```python
import frida  #导入frida模块
import sys    #导入sys模块

# 从此处开始定义用来Hook的javascript代码
jscode = """  
    Java.perform(function(){  
        var MainActivity = Java.use('com.example.testfrida.MainActivity'); //获得MainActivity类
        MainActivity.testFrida.implementation = function(){
            send('Statr! Hook!'); //发送信息，用于回调python中的函数
            return 'Change String!' //劫持返回值，修改为我们想要返回的字符串
        }
    });
"""

def on_message(message,data): #js中执行send函数后要回调的函数
    print(message)

process = frida.get_remote_device().attach('com.example.testfrida') #得到设备并劫持进程com.example.testfrida
script = process.create_script(jscode) #创建js脚本
script.on('message',on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数
script.load() #加载脚本
sys.stdin.read()
```
### HOOK方法
**hook普通方法**
```javascript
Java.perform(function () {
   var utils = Java.use('com.app.test');//Java.use('类名')
    // func为方法名
    utils.func.implementation = function (a) {
        console.log("Hook Start...");
        send(arguments[0]);  //打印方法第一个参数 用send(a)也行
    } }); 
```
**hook构造方法**
```javascript
Java.perform(function () { 	
	var utils = Java.use('com.app.test');
    utils.$init.implementation = function (a) {
        console.log("Hook Start..."); 	
        send(arguments[0]);
        return this.$init(1000);
    } }); 
```
**hook重载方法**
```javascript
Java.perform(function () {
    var utils = Java.use('com.app.test');
    utils.test.overload("int").implementation = function (a) {
        console.log("Hook Start...");
        send(arguments[0]);
        return "helloworld";
    } }); 
```
**hook构造对象参数**
```javascript
Java.perform(function () { 	
    var utils = Java.use('com.app.test'); 	
    var money = Java.use('com.qiang.fridaapp.Money');
    utils.test.overload().implementation = function () {
        // send("Hook Start...");
        // 拦截utils方法然后构造一个money方法返回
        var mon = money.$new(2000); 		
        // send(mon.getInfo()); 		
        return this.test(800);
    } }); 
```
**hook修改对象属性**
```javascript
Java.perform(function () {
    var utils = Java.use('com.qiang.fridaapp.Utils');
    var money = Java.use('com.qiang.fridaapp.Money');
    var clazz = Java.use('java.lang.Class');
    utils.test.overload().implementation = function () {
        send("Hook Start...");
       
        var mon = money.$new(200,"RMB");
        send(mon.getInfo());
        
        // 修改一个对象的内部值，利用反射进行操作，用cast获取对应类的class类型，
        var num= Java.cast(mon.getClass(),clazz).getDeclaredField('num');
        // 值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查;实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问,由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的 
        num.setAccessible(true);
       
        num.setInt(mon, 2000);
        send(mon.getInfo());
       
        return this.test();
    } }); 
```
### hook匿名内部类
```javascript
 Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
    } }); 
```
### hook打印堆栈信息
```javascript
Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
        printStack();
    }
    function printStack(){
        var threadef = Java.use('java.lang.Thread');
        var threadinstance = threadef.$new();
        var stack = threadinstance.currentThread().getStackTrace();
        for(var i = 0;i<stack.length;i++){
            send("stack:" + stack[i].toString());
        }
    } }); 
```
### fridarpc
```javascript
rpc.exports = { add: function (a, b) { return a + b; },
```
### 字节数组,字符串互转
```javascript
Java.perform(function () {
    var login = Java.use('com.app.login');
    login.onClick.implementation = function (a) {
        send("Hook Start...");
        var bytes=stringToBytes("hello world!")
        send(bytes); 
        var str=byteToString(bytes)
        send(str);
    }
    
    function stringToBytes(str) {  
        var ch, st, re = []; 
        for(var i = 0; i < str.length; i++ ) { 
            ch = str.charCodeAt(i);  
            st = [];                 
            do{
                st.push( ch & 0xFF );
                ch = ch >> 8;
            }
            while(ch);
            re = re.concat(st.reverse());
        }
        return re;  
    } 
    
    function byteToString(arr){  
        if(typeof arr === 'string'){  
            return arr;  
        }  
        var str='',  
        _arr = arr;  
        for(var i=0; i<_arr.length; i++) {  
            var one =_arr[i].toString(2), v=one.match(/^1+?(?=0)/);  
            if(v && one.length == 8){  
                var bytesLength = v[0].length;  
                var store = _arr[i].toString(2).slice(7 - bytesLength);  
                for(var st=1; st < bytesLength; st++) {  
                    store+=_arr[st + i].toString(2).slice(2);  
                }  
                str+=String.fromCharCode(parseInt(store, 2));  
                i+=bytesLength-1;  
            } else {  
                str+=String.fromCharCode(_arr[i]);  
            }  
        }  
        return str;  
    } });
```
### hook插件化apk
由于是插件化apk，类加载是在插件化框架自定义的，所以classloader不能使用默认的。
```javascript
Java.perform(function () {
    // 使用Java.enumerateClassLoaders(callbacks)来打印出所有的加载器
    Java.enumerateClassLoaders({
        "onMatch": function(loader) {
            try {
                if (loader.findClass('com.mango.hnxwlb.utils.Md5Util')) {
                    console.log(loader);
                    // 修改loader
                    Java.classFactory.loader = loader;
                }   
            } catch (error){
                console.log('not find');
            }
        },
        "onComplete": function() {
            console.log("success");
        },
    });
    // 使用Java.classFactory.use进行hook
    var videoController = Java.classFactory.use("com.mango.hnxwlb.utils.Md5Util");
    videoController.getToken.implementation = function(p0) {
        var gettoken = this.getToken();
        console.log(p0)
        console.log(gettoken)
        return gettoken;
    };
});
```
参考文章：[使用frida hook插件化apk](https://bbs.kanxue.com/thread-258772.htm#frida%E6%9E%9A%E4%B8%BEclassloader)
### 加密自吐
```python
import frida  
import sys  
jscode = """  
var allKeys = {};  
//工具相关函数 var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',  
    base64DecodeChars = new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));  
function bytesToString(arr) {  
    var str = '';    arr = new Uint8Array(arr);    for (var i in arr) {        str += String.fromCharCode(arr[i]);    }    return str;};  
  
function bytesToHex(arr) {  
    var str = '';    var k, j;    for (var i = 0; i < arr.length; i++) {        k = arr[i];        j = k;        if (k < 0) {            j = k + 256;        }        if (j < 16) {            str += "0";        }        str += j.toString(16);    }    return str;};  
function bytesToBase64(e) {  
    var r, a, c, h, o, t;    for (c = e.length, a = 0, r = ''; a < c;) {        if (h = 255 & e[a++], a == c) {            r += base64EncodeChars.charAt(h >> 2),                r += base64EncodeChars.charAt((3 & h) << 4),                r += '==';            break        }        if (o = e[a++], a == c) {            r += base64EncodeChars.charAt(h >> 2),                r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),                r += base64EncodeChars.charAt((15 & o) << 2),                r += '=';            break        }        t = e[a++],            r += base64EncodeChars.charAt(h >> 2),            r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),            r += base64EncodeChars.charAt((15 & o) << 2 | (192 & t) >> 6),            r += base64EncodeChars.charAt(63 & t)    }    return r};  
Java.perform(function(){  
    // md5    let md = Java.use("java.security.MessageDigest");    md.getInstance.overload('java.lang.String').implementation = function (a) {        send("======================================");        send("算法名：" + a);  
        return this.getInstance(a);    };    md.getInstance.overload('java.lang.String','java.lang.String').implementation = function (a,b) {        send("======================================");        send("算法名：" + a);  
        return this.getInstance(a, b);    };    md.update.overload('[B').implementation = function (a) {        send("参数:" + bytesToString(a))  
        return this.update(a);    };    md.update.overload('[B','int','int').implementation = function (a,b,c) {        send("参数:" + bytesToString(a) + "|" + b + "|" + c);  
        return this.update(a,b,c);    };    md.digest.overload().implementation = function () {        var result = this.digest();        send("digest结果:" + bytesToHex(result));  
        return result;    };    md.digest.overload('[B').implementation = function (a) {        send("digest参数:" + bytesToString(a));  
        var result = this.digest(a);        send("digest结果:" + bytesToHex(result));  
        return result;    };        // aes,des,rsa等加密  
    var cipher = Java.use("javax.crypto.Cipher");    for (let index = 0; index < cipher.init.overloads.length; index++) {        cipher.init.overloads[index].implementation = function () {            allKeys[this.toString()] = arguments[1].getEncoded();            this.init.apply(this, arguments);        }    };    var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec');    x509EncodedKeySpec.$init.overload('[B').implementation = function (a) {        var result = this.$init(a);        send("======================================");        send("RSA公钥:" + bytesToBase64(a));  
        return result;    }    var PKCS8EncodedKeySpec = Java.use('java.security.spec.PKCS8EncodedKeySpec');    PKCS8EncodedKeySpec.$init.overload('[B').implementation = function (a) {        var result = this.$init(a);        send("RSA私钥:" + bytesToBase64(a));  
        return result;    }    for (let index = 0; index < cipher.doFinal.overloads.length; index++) {        cipher.doFinal.overloads[index].implementation = function () {            var dict = {};            dict["EorD"] = this.opmode.value; //模式 加密解密  
            dict["method"] = this.transformation.value; //加密类型  
            var iv =  this.spi.value.engineGetIV();            if (iv){                dict["iv"] = bytesToHex(iv);            }else{                dict["iv"] = "";            }            if (allKeys[this.toString()]){                dict["password"] = bytesToString(allKeys[this.toString()])            }else{                dict["password"] = "";            }            var retVal = this.doFinal.apply(this, arguments);            dict["receData"] = "";            dict["resData"] = "";            if (arguments.length >= 1 && arguments[0].$className != "java.nio.ByteBuffer") {                dict['receData'] = bytesToString(arguments[0]);                dict["hexresData"] = bytesToHex(retVal);                dict["base64resData"] = bytesToBase64(retVal);            }            if(dict["EorD"] == 1){                send("======================================");                send(dict);            }            return retVal;        }    };});  
"""  
  
  
def on_message(message, data):  # js中执行send函数后要回调的函数  
    if message['type'] == "send":  
        data = message['payload']  
        if isinstance(data, dict):  
            method = data["method"]  
            EorD = data["EorD"]  
            password = data["password"]  
            iv = data["iv"]  
            if EorD == 1:  
                receData = data["receData"]  
                hexresData = data["hexresData"]  
                base64resData = data["base64resData"]  
                if method == 'RSA':  
                    print('加密：{}\n参数：{}\n结果：\n  hex:{}\n  base64:{}'.format(method, receData, hexresData, base64resData))  
                else:  
                    print('加密：{}\n参数：{}\n结果：\n  hex:{}\n  base64:{}\n密钥：{}\niv：{}'.format(method, receData, hexresData, base64resData, password, iv))  
  
        else:  
            print(data)  
  
  
process = frida.get_remote_device().attach('cdemo')  
script = process.create_script(jscode)  # 创建js脚本  
script.on('message', on_message)  # 加载回调函数  
script.load()  
sys.stdin.read()
```
## 反调试
**检测frida-server文件名 ,检测27042默认端口：**   
修改frida-server文件名，修改转发端口。  
**检测D-Bus：** 
**检测/proc/pid/maps映射文件：**   
当挂上frida后对应的maps文件中会出现re.frida.server之类的特征，这是在使用frida server的时候自动创建的，其中存放着frida的功能模块,hook跳过检测：
```javascript
function main() {
  const openPtr = Module.getExportByName('libc.so', 'open');
  const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);
  var readPtr = Module.findExportByName("libc.so", "read");
  var read = new NativeFunction(readPtr, 'int', ['int', 'pointer', "int"]);
  var fakePath = "/data/data/com.app/maps";
  var file = new File(fakePath, "w");
  var buffer = Memory.alloc(512);
  Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) {
      var pathname = Memory.readUtf8String(pathnameptr);
      var realFd = open(pathnameptr, flag);
      if (pathname.indexOf("maps") >= 0) {
          while (parseInt(read(realFd, buffer, 512)) !== 0) {
              var oneLine = Memory.readCString(buffer);
              if (oneLine.indexOf("tmp") === -1) {
                  file.write(oneLine);
              }
          }
          var filename = Memory.allocUtf8String(fakePath);
          return open(filename, flag);
      }
      var fd = open(pathnameptr, flag);
      return fd;
  }, 'int', ['pointer', 'int']));
}
setImmediate(main)
```

**检测/proc/pid/tast/tid/stat或/proc/pid/tast/tid/status** 
**双进程保护：**
用spawn模式启动app `frida -U -f com.asiainfo.app --no-pause` 之后进行hook `frida -U com.asiainfo.app -l test.js`