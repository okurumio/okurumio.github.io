---
title: 对称加密
date: 2023-02-10 10:10:23
permalink: /cs/cryptology/symmetric/
categories: 
  - 网络安全
tags: 
  - 
---

## DES
对称加密算法，使用一个56位的密钥以及附加的8位奇偶校验位，产生最大64位的分组大小。这是一个迭代的分组密码，使用称为Feistel的技术，其中将加密的文本块分成两半。  
使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES使用16个循环，使用异或，置换，代换，移位操作四种基本运算。  
常见的填充模式有：'pkcs5'、'pkcs7'、'iso10126'、'ansix923'、'zero' 类型，包括DES-ECB、DES-CBC、DES-CTR、DES-OFB、DES-CFB。  

### des加密实现
**python实现des加密**
```python
from pyDes import des, CBC, PAD_PKCS5
import secrets
import binascii

# 从指定序列中随机生成密钥
def pro_secretkey():
    secretkey = ''
    for i in range(8):
        secretkey += secrets.choice('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    return secretkey

# des加密
def des_encrypt(plaintext, secretkey):
    iv = secretkey
    k = des(secretkey, CBC, iv, pad=None, padmode=PAD_PKCS5)
    en = k.encrypt(plaintext.encode(), padmode=PAD_PKCS5)
    return binascii.b2a_hex(en).decode()

# des解密
def des_descrypt(ciphertext, secretkey):
    iv = secretkey
    k = des(secretkey, CBC, iv, pad=None, padmode=PAD_PKCS5)
    ciphertext = k.decrypt(binascii.a2b_hex(ciphertext), padmode=PAD_PKCS5)
    return ciphertext

if __name__ == "__main__":
    text = 'des加密'
    print('明文为：', text)
    secretkey = pro_secretkey()
    print('密钥为：', secretkey)
    # 加密原文
    ciphertext = des_encrypt(text, secretkey)
    print('密文为：', ciphertext)
    # 解密密文
    des = des_descrypt(ciphertext, secretkey)
    print('解密后：', des.decode())
```
**js实现des加密**
```javascript
var script = document.createElement('script');
script.src = "https://cdn.bootcss.com/crypto-js/3.1.9-1/crypto-js.min.js";
document.head.appendChild(script);

function decryptByDES(ciphertext, key){
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var decrypted = CryptoJS.DES.decrypt({
        ciphertext: CryptoJS.enc.Hex.parse(ciphertext)
    }, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.ZeroPadding
    });
    var result_value = decrypted.toString(CryptoJS.enc.Utf8);
    console.log(result_value)
    return result_value;
}

function encryptByDES(message, key){
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.toString();
}
```
## AES
对称加密算法，AES加密过程涉及到4种操作，分别是字节替代、行移位、列混淆和轮密钥加。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16个字节的明文、密文和轮密钥都以一个4x4的矩阵表示。
### aes加密实现
**python实现aes加密**
```python
import base64
from Crypto.Cipher import AES

def add_to_16(text: str) -> bytes:
    b_text = text.encode('utf-8')
    # 计算需要补的为位数
    if len(text) % 16:
        add = 16 - (len(b_text) % 16)
    else:
        add = 0
    return b_text + (b'\0' * add)

def encrypt(text, key):
    key = key.encode('utf-8')
    text = add_to_16(text)  # 如果长度不够补足 16 位
    cryptos = AES.new(key, AES.MODE_ECB)  # 使用ECB模式
    cipher_text = cryptos.encrypt(text)  # 加密
    return base64.standard_b64encode(cipher_text).decode('utf-8')  # 将加密结果转为base64编码输出

def decrypt(text, key):
    key = key.encode('utf-8')
    text = text.encode('utf-8')
    text = base64.b64decode(text)  # 先使用base64解码
    cryptos = AES.new(key, AES.MODE_ECB)
    cipher_text = cryptos.decrypt(text)  # 解密
    return cipher_text.decode('utf-8').strip('\0')

if __name__ == '__main__':
    source_str = 'hello'
    AES_KEY = 'aw123zsc212s9ju0'
    encrypt_str = encrypt(source_str, AES_KEY)
    decrypt_str = decrypt(encrypt_str, AES_KEY)
    print(encrypt_str)
    print(decrypt_str)
```
**js实现aes加密**
```javascript
// AES加密
function encrypt(str) {
    var decArray = hexStrToDecArray(str);
    var wordArray = int8parse(decArray);
    var encrypted = CryptoJS.AES.encrypt(wordArray, aesKeyBytes(), {
        mode: CryptoJS.mode.ECB, 
        padding: CryptoJS.pad.NoPadding
    });
    return wordArrayToHexStr(encrypted.ciphertext.words);
}

// AES解密
function decrypt(str) {
    var decArray = hexStrToDecArray(str);
    var wordArray = int8parse(decArray);
    var base64Str = CryptoJS.enc.Base64.stringify(wordArray);
    var decrypted = CryptoJS.AES.decrypt(base64Str, aesKeyBytes(), {
        mode: CryptoJS.mode.ECB, 
        padding: CryptoJS.pad.NoPadding
    });
    return wordArrayToHexStr(decrypted.words);
}
```
## xxtea
该算法使用 128 位的密钥为 64 位的信息块进行加密，它需要进行 64 轮迭代。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9 ）。
### xxtea加密实现
**javascript实现xxtea加密**
```javascript
function utf8to16(str) {
    var out, i, len, c;
    var char2, char3;
    out = [];
    len = str.length;
    i = 0;
    while (i < len) {
        c = str.charCodeAt(i++);
        switch (c >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                out[out.length] = str.charAt(i - 1);
                break;
            case 12:
            case 13:
                char2 = str.charCodeAt(i++);
                out[out.length] = String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                break;
            case 14:
                char2 = str.charCodeAt(i++);
                char3 = str.charCodeAt(i++);
                out[out.length] = String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
                break;
        }
    }
    return out.join('');
}
var base64DecodeChars = new Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);

function base64decode(str) {
    var c1, c2, c3, c4;
    var i, len, out;
    len = str.length;
    i = 0;
    out = "";
    while (i < len) {
        do {
            c1 = base64DecodeChars[str.charCodeAt(i++) & 0xff]
        } while (i < len && c1 == -1);
        if (c1 == -1)
            break;
        do {
            c2 = base64DecodeChars[str.charCodeAt(i++) & 0xff]
        } while (i < len && c2 == -1);
        if (c2 == -1)
            break;
        out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
        do {
            c3 = str.charCodeAt(i++) & 0xff;
            if (c3 == 61)
                return out;
            c3 = base64DecodeChars[c3]
        } while (i < len && c3 == -1);
        if (c3 == -1)
            break;
        out += String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));
        do {
            c4 = str.charCodeAt(i++) & 0xff;
            if (c4 == 61)
                return out;
            c4 = base64DecodeChars[c4]
        } while (i < len && c4 == -1);
        if (c4 == -1)
            break;
        out += String.fromCharCode(((c3 & 0x03) << 6) | c4)
    }
    return out
}

function long2str(v, w) {
    var vl = v.length;
    var sl = v[vl - 1] & 0xffffffff;
    for (var i = 0; i < vl; i++) {
        v[i] = String.fromCharCode(v[i] & 0xff, v[i] >>> 8 & 0xff, v[i] >>> 16 & 0xff, v[i] >>> 24 & 0xff);
    }
    if (w) {
        return v.join('').substring(0, sl);
    } else {
        return v.join('');
    }
}

function str2long(s, w) {
    var len = s.length;
    var v = [];
    for (var i = 0; i < len; i += 4) {
        v[i >> 2] = s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16 | s.charCodeAt(i + 3) << 24;
    }
    if (w) {
        v[v.length] = len;
    }
    return v;
}

function xxtea_decrypt(str, key) {
    if (str == "") {
        return "";
    }
    var v = str2long(str, false);
    var k = str2long(key, false);
    var n = v.length - 1;
    var z = v[n - 1],
        y = v[0],
        delta = 0x9E3779B9;
    var mx, e, q = Math.floor(6 + 52 / (n + 1)),
        sum = q * delta & 0xffffffff;
    while (sum != 0) {
        e = sum >>> 2 & 3;
        for (var p = n; p > 0; p--) {
            z = v[p - 1];
            mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
            y = v[p] = v[p] - mx & 0xffffffff;
        }
        z = v[n];
        mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
        y = v[0] = v[0] - mx & 0xffffffff;
        sum = sum - delta & 0xffffffff;
    }
    return long2str(v, true);
}

function decrypt(x){
    tt = utf8to16(xxtea_decrypt(base64decode(x), '5b28bae827e651b3'));
    return tt
}
```